"""
Cliente unificado para interacci√≥n con el SII - RPA v3
"""
import logging
from typing import Dict, Any, List, Optional

from .core import SeleniumDriver, Authenticator, SessionManager
from .extractors import ContribuyenteExtractor, F29Extractor, DTEExtractor
from .config import config as default_config
from .exceptions import AuthenticationError, ExtractionError

logger = logging.getLogger(__name__)


class SIIClient:
    """
    Cliente unificado para todas las operaciones del SII.

    Funcionalidades:
    1. Autenticaci√≥n y gesti√≥n de cookies (100% en memoria, sin DB)
    2. Extracci√≥n de datos del contribuyente
    3. Extracci√≥n de DTEs (compra/venta) v√≠a API
    4. Extracci√≥n de formularios F29

    Ejemplo b√°sico (sin cookies previas):
        with SIIClient(tax_id="12345678-9", password="secret") as client:
            # Hacer login y obtener cookies
            client.login()
            cookies = client.get_cookies()  # Guardar cookies para reutilizar

            # Extraer datos
            info = client.get_contribuyente()
            compras = client.get_compras(periodo="202501")

    Ejemplo con cookies existentes (sin login/RPA):
        # Reutilizar cookies de una sesi√≥n anterior
        with SIIClient(tax_id="12345678-9", password="secret", cookies=saved_cookies) as client:
            # No necesita login, usa las cookies provistas
            info = client.get_contribuyente()  # Usa cookies directamente
            compras = client.get_compras(periodo="202501")  # Sin abrir navegador
    """

    def __init__(
        self,
        tax_id: str,
        password: str,
        headless: bool = True,
        config: Optional[Dict] = None,
        cookies: Optional[List[Dict]] = None
    ):
        """
        Inicializa el cliente SII

        Args:
            tax_id: RUT del contribuyente (formato: 12345678-9)
            password: Contrase√±a del SII
            headless: Ejecutar navegador en modo headless
            config: Configuraci√≥n opcional (dict con timeout, window_size, etc)
            cookies: Cookies de sesi√≥n existentes (opcional). Si se proveen, se intentar√°
                    usarlas sin hacer login. Si no funcionan, se har√° login autom√°ticamente.
        """
        self.tax_id = tax_id
        self.password = password
        self.headless = headless
        self.custom_config = config or {}
        self.custom_config['headless'] = headless

        # Cookies iniciales (pueden venir de fuera)
        self._initial_cookies = cookies

        # Componentes core (lazy initialization)
        self._driver: Optional[SeleniumDriver] = None
        self._session_manager: Optional[SessionManager] = None
        self._authenticator: Optional[Authenticator] = None

        # Extractores (lazy initialization)
        self._contribuyente_extractor: Optional[ContribuyenteExtractor] = None
        self._f29_extractor: Optional[F29Extractor] = None
        self._dte_extractor: Optional[DTEExtractor] = None

        # Estado
        self._initialized = False
        self._authenticated = False
        self._current_cookies: Optional[List[Dict]] = cookies  # Cookies actuales en memoria

        logger.debug(f"üöÄ SIIClient initialized for {tax_id}")
        if cookies:
            logger.debug(f"üç™ Initialized with {len(cookies)} cookies")

    # ==========================================
    # INICIALIZACI√ìN Y RECURSOS
    # ==========================================

    def _ensure_initialized(self):
        """Asegura que el cliente est√© inicializado"""
        if not self._initialized:
            self._initialize()

    def _initialize(self):
        """Inicializa los componentes core"""
        if self._initialized:
            return

        logger.debug("üîß Initializing SIIClient components...")

        # Inicializar driver
        self._driver = SeleniumDriver(custom_config=self.custom_config)
        self._driver.start()

        # Inicializar session manager con cookies iniciales si existen
        self._session_manager = SessionManager(
            tax_id=self.tax_id,
            cookies=self._initial_cookies
        )

        # Inicializar authenticator
        self._authenticator = Authenticator(
            driver=self._driver,
            session_manager=self._session_manager,
            tax_id=self.tax_id,
            password=self.password
        )

        self._initialized = True
        logger.debug("‚úÖ SIIClient components initialized")

    def close(self) -> None:
        """Cierra el cliente y libera recursos"""
        logger.debug("üî¥ Closing SIIClient...")

        # Cerrar extractores
        if self._dte_extractor:
            self._dte_extractor.close()

        # Cerrar driver
        if self._driver:
            self._driver.quit()

        # Limpiar referencias
        self._driver = None
        self._session_manager = None
        self._authenticator = None
        self._contribuyente_extractor = None
        self._f29_extractor = None
        self._dte_extractor = None

        self._initialized = False
        self._authenticated = False

        logger.debug("‚úÖ SIIClient closed")

    def __enter__(self):
        """Context manager entry"""
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """Context manager exit"""
        self.close()

    # ==========================================
    # 1. AUTENTICACI√ìN Y COOKIES
    # ==========================================

    def login(self, force_new: bool = False) -> bool:
        """
        Autentica con el SII

        Args:
            force_new: Forzar nueva autenticaci√≥n (ignorar cookies guardadas)

        Returns:
            True si autenticaci√≥n exitosa

        Raises:
            AuthenticationError: Si falla la autenticaci√≥n
        """
        self._ensure_initialized()

        logger.info(f"üîê Login (force_new={force_new})...")
        self._authenticated = self._authenticator.authenticate(force_new=force_new)

        # Actualizar cookies en memoria despu√©s de login exitoso
        if self._authenticated:
            self._current_cookies = self._driver.get_cookies()
            logger.debug(f"üç™ Cached {len(self._current_cookies)} cookies after login")

        return self._authenticated

    def get_cookies(self) -> List[Dict]:
        """
        Obtiene las cookies de sesi√≥n actuales

        Estrategia:
        1. Si hay cookies en memoria (_current_cookies), las devuelve
        2. Si no hay cookies y est√° autenticado, las obtiene del driver
        3. Si no est√° autenticado, hace login y devuelve las cookies

        Returns:
            Lista de cookies en formato dict

        Raises:
            AuthenticationError: Si no hay sesi√≥n autenticada
        """
        # Si ya tenemos cookies en memoria, devolverlas
        if self._current_cookies:
            logger.debug(f"üç™ Returning {len(self._current_cookies)} cookies from memory")
            return self._current_cookies

        self._ensure_initialized()

        # Si no est√° autenticado, hacer login
        if not self._authenticated:
            logger.debug("üîê No active session, authenticating...")
            self.login()

        # Obtener cookies del driver y guardarlas en memoria
        cookies = self._driver.get_cookies()
        self._current_cookies = cookies
        logger.debug(f"üç™ Retrieved and cached {len(cookies)} cookies")
        return cookies

    def is_authenticated(self) -> bool:
        """
        Verifica si hay una sesi√≥n autenticada activa

        Returns:
            True si hay sesi√≥n activa
        """
        if self._authenticated:
            return True

        if self._session_manager:
            return self._session_manager.has_valid_session()

        return False

    # ==========================================
    # 2. DATOS DEL CONTRIBUYENTE
    # ==========================================

    def get_contribuyente(self) -> Dict[str, Any]:
        """
        Obtiene informaci√≥n completa del contribuyente

        Estrategia:
        1. Si el cliente se inicializ√≥ con cookies, las usa directamente (sin RPA)
        2. Si no hay cookies o fallan, hace login con RPA
        3. Extrae datos via API usando las cookies

        Returns:
            Dict con:
            - rut: str
            - razon_social: str
            - nombre: str
            - direccion: str
            - comuna: str
            - email: str
            - telefono: str
            - actividad_economica: str
            - fecha_inicio_actividades: str

        Raises:
            ExtractionError: Si falla la extracci√≥n
        """
        self._ensure_initialized()

        # Lazy loading del extractor
        if not self._contribuyente_extractor:
            self._contribuyente_extractor = ContribuyenteExtractor(self._driver)

        # PASO 1: Intentar con cookies en memoria (sin RPA)
        if self._current_cookies:
            logger.debug("üç™ Using provided cookies for contribuyente extraction (no RPA needed)")
            try:
                # Intentar extraer con cookies provistas
                return self._contribuyente_extractor.extract(
                    tax_id=self.tax_id,
                    cookies=self._current_cookies
                )
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è Provided cookies failed: {e}. Will retry with fresh login.")
                # Si falla, continuar con login

        # PASO 2: Si no hay cookies v√°lidas o fallaron, hacer login con RPA
        logger.debug("üîê No valid cookies - performing RPA login")
        if not self._authenticated:
            self.login()

        # Extraer con cookies frescas del driver
        return self._contribuyente_extractor.extract(self.tax_id)

    # ==========================================
    # 3. DOCUMENTOS TRIBUTARIOS (API)
    # ==========================================

    def get_compras(
        self,
        periodo: str,
        tipo_doc: str = "33"
    ) -> Dict[str, Any]:
        """
        Obtiene documentos de compra v√≠a API del SII

        Args:
            periodo: Per√≠odo tributario (formato YYYYMM, ej: "202501")
            tipo_doc: C√≥digo tipo documento (default "33" = factura electr√≥nica)

        Returns:
            Dict con:
            - status: 'success' | 'error'
            - data: List[Dict] con documentos
            - extraction_method: str
            - periodo_tributario: str

        Raises:
            ExtractionError: Si falla la extracci√≥n
        """
        # Lazy loading del extractor DTE
        if not self._dte_extractor:
            self._dte_extractor = DTEExtractor(tax_id=self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._dte_extractor.extract_compras(periodo, tipo_doc, cookies)

    def get_ventas(
        self,
        periodo: str,
        tipo_doc: str = "33"
    ) -> Dict[str, Any]:
        """
        Obtiene documentos de venta v√≠a API del SII

        Args:
            periodo: Per√≠odo tributario (formato YYYYMM)
            tipo_doc: C√≥digo tipo documento

        Returns:
            Dict con documentos de venta

        Raises:
            ExtractionError: Si falla la extracci√≥n
        """
        # Lazy loading del extractor DTE
        if not self._dte_extractor:
            self._dte_extractor = DTEExtractor(tax_id=self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._dte_extractor.extract_ventas(periodo, tipo_doc, cookies)

    def get_resumen(self, periodo: str) -> Dict[str, Any]:
        """
        Obtiene resumen de compras y ventas del per√≠odo

        Args:
            periodo: Per√≠odo tributario (YYYYMM)

        Returns:
            Dict con totales por tipo de documento

        Raises:
            ExtractionError: Si falla la extracci√≥n
        """
        # Lazy loading del extractor DTE
        if not self._dte_extractor:
            self._dte_extractor = DTEExtractor(tax_id=self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._dte_extractor.extract_resumen(periodo, cookies)

    def get_boletas_diarias(
        self,
        periodo: str,
        tipo_doc: str
    ) -> Dict[str, Any]:
        """
        Obtiene boletas o comprobantes diarios del per√≠odo

        Args:
            periodo: Per√≠odo tributario (YYYYMM)
            tipo_doc: Tipo de documento ("39" = boletas, "48" = comprobantes)

        Returns:
            Dict con totales diarios

        Raises:
            ExtractionError: Si falla la extracci√≥n
        """
        # Lazy loading del extractor DTE
        if not self._dte_extractor:
            self._dte_extractor = DTEExtractor(tax_id=self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._dte_extractor.extract_boletas_diarias(periodo, tipo_doc, cookies)

    # ==========================================
    # 4. FORMULARIOS F29
    # ==========================================

    def get_f29_lista(
        self,
        anio: str,
        folio: Optional[str] = None
    ) -> List[Dict]:
        """
        Busca formularios F29

        Args:
            anio: A√±o (formato YYYY, ej: "2024")
            folio: Folio espec√≠fico (opcional)

        Returns:
            Lista de formularios F29 encontrados

        Raises:
            ExtractionError: Si falla la b√∫squeda
        """
        self._ensure_initialized()

        # Asegurar autenticaci√≥n FRESCA para F29
        # F29 requiere login directo, no funciona con sesiones reutilizadas
        logger.info("üîê F29 requires fresh authentication...")
        self.login(force_new=True)

        # Lazy loading del extractor
        if not self._f29_extractor:
            self._f29_extractor = F29Extractor(self._driver, self.tax_id)

        return self._f29_extractor.search(anio, folio)

    def get_f29_compacto(
        self,
        folio: str,
        id_interno_sii: str
    ) -> Optional[bytes]:
        """
        Descarga el PDF del formulario F29 compacto

        Args:
            folio: Folio del formulario
            id_interno_sii: ID interno del SII (obtenido de get_f29_lista)

        Returns:
            PDF en bytes, o None si falla

        Example:
            >>> formularios = client.get_f29_lista("2024")
            >>> f29 = formularios[0]
            >>> pdf = client.get_f29_compacto(f29['folio'], f29['id_interno_sii'])
            >>> with open('f29.pdf', 'wb') as f:
            ...     f.write(pdf)

        Raises:
            ExtractionError: Si falla la descarga
        """
        # Lazy loading del extractor
        if not self._f29_extractor:
            self._f29_extractor = F29Extractor(self._driver, self.tax_id)

        return self._f29_extractor.get_formulario_compacto(
            folio=folio,
            id_interno_sii=id_interno_sii
        )

    def get_propuesta_f29(self, periodo: str) -> Dict[str, Any]:
        """
        Obtiene la propuesta de declaraci√≥n F29 pre-calculada por el SII.

        Este m√©todo consulta el endpoint que devuelve el F29 con valores
        pre-llenados autom√°ticamente por el SII, incluyendo c√≥digos propuestos
        basados en los DTEs del per√≠odo.

        Args:
            periodo: Per√≠odo tributario en formato YYYYMM (ej: "202510")

        Returns:
            Dict con la propuesta completa del F29:
            {
                'data': {
                    'tipopropuesta': int,
                    'listCondiciones': List[Dict],  # Condiciones del contribuyente
                    'listCodPropuestos': List[Dict],  # C√≥digos con valores calculados
                    'listGlosasProp': List[Dict],  # Mensajes informativos
                    'listCodBase': List[Dict],  # Info del contribuyente
                    'listCodComplementar': List[int],  # C√≥digos a completar manualmente
                    'complementoDetalleDTE': bool,
                    'documentosDelGiro': bool,
                    ...
                },
                'metaData': {...}
            }

        Raises:
            ExtractionError: Si falla la obtenci√≥n de la propuesta

        Example:
            >>> propuesta = client.get_propuesta_f29("202510")
            >>> codigos = propuesta['data']['listCodPropuestos']
            >>> # [{"codigo": "502", "valor": "1545"}, {"codigo": "111", "valor": "41589"}, ...]
            >>>
            >>> # C√≥digos que requieren ser completados manualmente
            >>> codigos_manual = propuesta['data']['listCodComplementar']
            >>> # [500, 501]
        """
        # Lazy loading del extractor
        if not self._f29_extractor:
            self._f29_extractor = F29Extractor(self._driver, self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._f29_extractor.get_declaracion_propuesta(
            periodo=periodo,
            cookies=cookies
        )

    def get_tasa_ppmo(
        self,
        periodo: str,
        categoria_tributaria: int = 1,
        tipo_formulario: str = "FMNINT"
    ) -> Dict[str, Any]:
        """
        Obtiene la tasa de PPMO (Pagos Provisionales Mensuales Obligatorios).

        Este m√©todo consulta la tasa de PPM que el contribuyente debe aplicar
        seg√∫n su categor√≠a tributaria y situaci√≥n.

        Args:
            periodo: Per√≠odo tributario en formato YYYYMM (ej: "202510")
            categoria_tributaria: Categor√≠a tributaria (1=Primera categor√≠a, default: 1)
            tipo_formulario: Tipo de formulario (default: "FMNINT")

        Returns:
            Dict con informaci√≥n de tasa PPMO:
            {
                'data': {
                    'cod563': str,  # Ingresos brutos del per√≠odo
                    'cod115': str,  # Tasa de PPM (ej: "0.125" = 12.5%)
                    'cod563Propuesto': str,
                    'categoriaTributaria': int,
                    'esPropyme': bool,  # Si es ProPyme
                    'tasaIDPC': str,  # Tasa IDPC
                    'periodo': str,
                    ...
                },
                'metaData': {...}
            }

        Raises:
            ExtractionError: Si falla la obtenci√≥n

        Example:
            >>> tasa_info = client.get_tasa_ppmo("202510")
            >>> tasa = tasa_info['data']['cod115']  # "0.125"
            >>> ingresos = tasa_info['data']['cod563']  # "3384732"
            >>> es_propyme = tasa_info['data']['esPropyme']  # True/False
        """
        # Lazy loading del extractor
        if not self._f29_extractor:
            self._f29_extractor = F29Extractor(self._driver, self.tax_id)

        # Obtener cookies (hacer login si es necesario)
        cookies = self.get_cookies()

        return self._f29_extractor.get_tasa_ppmo(
            periodo=periodo,
            categoria_tributaria=categoria_tributaria,
            tipo_formulario=tipo_formulario,
            cookies=cookies
        )

    # ==========================================
    # 5. BOLETAS DE HONORARIOS
    # ==========================================

    def get_boletas_honorarios(
        self,
        mes: str,
        anio: str,
        max_retries: int = 3
    ) -> Dict[str, Any]:
        """
        Obtiene boletas de honorarios para un per√≠odo espec√≠fico.

        Este m√©todo consulta las boletas de honorarios emitidas usando el
        endpoint de la Propuesta F29 del SII.

        Args:
            mes: Mes a consultar (1-12, puede ser string "1" o "01")
            anio: A√±o a consultar (formato YYYY, ej: "2025")
            max_retries: N√∫mero m√°ximo de reintentos en caso de error

        Returns:
            Dict con boletas y totales:
            {
                'boletas': [
                    {
                        'numero_boleta': int,
                        'estado': str,  # 'VIG' (Vigente) o 'ANU' (Anulada)
                        'fecha_boleta': str,
                        'fecha_emision': str,
                        'usuario_emision': str,
                        'sociedad_profesional': bool,
                        'rut_receptor': str,
                        'nombre_receptor': str,
                        'honorarios_brutos': int,
                        'retencion_emisor': int,
                        'retencion_receptor': int,
                        'honorarios_liquidos': int,
                        'manual': bool
                    },
                    ...
                ],
                'totales': {
                    'honorarios_bruto': int,
                    'honorarios_retencion_emisor': int,
                    'honorarios_retencion_receptor': int,
                    'honorarios_liquido': int,
                    'total_registros': int,
                    'bhep': bool  # Boleta de Honorarios Electr√≥nica de Pago
                },
                'paginacion': {
                    'pagina_actual': int,
                    'total_paginas': int,
                    'tam_pagina': int
                }
            }

        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            ExtractionError: Si falla la obtenci√≥n de las boletas

        Example:
            >>> boletas = client.get_boletas_honorarios(mes="10", anio="2025")
            >>> print(f"Total boletas: {boletas['totales']['total_registros']}")
            >>> print(f"Total bruto: ${boletas['totales']['honorarios_bruto']:,}")
            >>>
            >>> for boleta in boletas['boletas']:
            ...     print(f"Boleta #{boleta['numero_boleta']}: ${boleta['honorarios_brutos']:,}")
        """
        from .scrapers.boletas_honorario_scraper import BoletasHonorarioScraper

        self._ensure_initialized()

        # Asegurar autenticaci√≥n
        logger.info("üîê Boletas de honorarios require authentication...")
        self.login()

        # Crear scraper
        scraper = BoletasHonorarioScraper(self._driver)

        try:
            return scraper.obtener_boletas(
                mes=mes,
                anio=anio,
                max_retries=max_retries
            )
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo boletas de honorarios: {e}")
            raise ExtractionError(f"Error obteniendo boletas de honorarios: {str(e)}") from e

    def get_boletas_honorarios_todas_paginas(
        self,
        mes: str,
        anio: str,
        max_retries: int = 3
    ) -> Dict[str, Any]:
        """
        Obtiene TODAS las p√°ginas de boletas de honorarios para un per√≠odo.

        A diferencia de get_boletas_honorarios() que solo obtiene la primera p√°gina,
        este m√©todo itera autom√°ticamente sobre todas las p√°ginas disponibles y
        retorna todas las boletas del per√≠odo.

        Args:
            mes: Mes a consultar (1-12, puede ser string "1" o "01")
            anio: A√±o a consultar (formato YYYY, ej: "2025")
            max_retries: N√∫mero m√°ximo de reintentos por p√°gina

        Returns:
            Dict con todas las boletas y totales (mismo formato que get_boletas_honorarios)

        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            ExtractionError: Si falla la obtenci√≥n de las boletas

        Example:
            >>> # Si hay 45 boletas (5 p√°ginas de 10)
            >>> boletas = client.get_boletas_honorarios_todas_paginas(mes="10", anio="2025")
            >>> print(f"Total boletas: {len(boletas['boletas'])}")  # 45
            >>> print(f"Total p√°ginas obtenidas: {boletas['paginacion']['total_paginas']}")  # 5
        """
        from .scrapers.boletas_honorario_scraper import BoletasHonorarioScraper

        self._ensure_initialized()

        # Asegurar autenticaci√≥n
        logger.info("üîê Boletas de honorarios require authentication...")
        self.login()

        # Crear scraper
        scraper = BoletasHonorarioScraper(self._driver)

        try:
            return scraper.obtener_todas_las_paginas(
                mes=mes,
                anio=anio,
                max_retries=max_retries
            )
        except Exception as e:
            logger.error(f"‚ùå Error obteniendo boletas de honorarios (todas p√°ginas): {e}")
            raise ExtractionError(f"Error obteniendo boletas de honorarios: {str(e)}") from e

    def get_declaraciones_con_estados(
        self,
        mes: str,
        anio: str,
        form_id: str = "2",
        max_retries: int = 3
    ) -> List[Dict[str, Any]]:
        """
        Obtiene declaraciones F29 con sus estados para un per√≠odo espec√≠fico.

        Este m√©todo consulta las declaraciones presentadas y sus estados
        (presentada, rectificada, anulada, etc.) usando el endpoint del SII.

        Args:
            mes: Mes a consultar (1-12, puede ser string "1" o "01")
            anio: A√±o a consultar (formato YYYY, ej: "2025")
            form_id: ID del formulario (default: "2" para F29)
            max_retries: N√∫mero m√°ximo de reintentos en caso de error

        Returns:
            Lista de declaraciones con sus estados:
            [
                {
                    'folio': str,               # Folio de la declaraci√≥n
                    'estado': str,              # Estado: PRESENTADA, RECTIFICADA, etc.
                    'fecha_presentacion': str,  # Fecha de presentaci√≥n
                    'tipo_declaracion': str,    # Original, Rectificatoria
                    'monto_declarado': int,     # Monto total declarado
                    'periodo': str,             # Per√≠odo (YYYYMM)
                    # ... m√°s campos seg√∫n respuesta del SII
                },
                ...
            ]

            Si no hay declaraciones, retorna lista vac√≠a: []

        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            ExtractionError: Si falla la obtenci√≥n

        Example:
            >>> # Obtener declaraciones de octubre 2025
            >>> declaraciones = client.get_declaraciones_con_estados(mes="10", anio="2025")
            >>>
            >>> if declaraciones:
            ...     for decl in declaraciones:
            ...         print(f"Folio: {decl['folio']}, Estado: {decl['estado']}")
            ... else:
            ...     print("No hay declaraciones para este per√≠odo")

        Note:
            - Retorna lista vac√≠a si no hay declaraciones presentadas
            - El form_id "2" corresponde al Formulario 29
            - √ötil para verificar si ya existe una declaraci√≥n antes de crear una nueva
        """
        from .scrapers.boletas_honorario_scraper import BoletasHonorarioScraper

        # Validar par√°metros
        if not mes or not anio:
            raise ValueError("Debe especificar mes y a√±o")

        if not mes.isdigit() or not (1 <= int(mes) <= 12):
            raise ValueError("El mes debe ser un n√∫mero entre 1 y 12")

        if not anio.isdigit() or len(anio) != 4:
            raise ValueError("El a√±o debe ser un n√∫mero de 4 d√≠gitos")

        self._ensure_initialized()

        # Asegurar autenticaci√≥n
        logger.info("üîê Declaraciones con estados require authentication...")
        self.login()

        try:
            # Obtener datos del RUT
            scraper = BoletasHonorarioScraper(self._driver)
            rut_contribuyente, dv = scraper._obtener_datos_empresa()

            # Construir payload
            import uuid
            import random
            import string

            conversation_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
            transaction_id = str(uuid.uuid4())

            payload = {
                "metaData": {
                    "namespace": "cl.sii.sdi.lob.iva.propuestaf29.data.api.interfaces.FacadeAdapterService/getDeclaracionConEstados",
                    "conversationId": conversation_id,
                    "transactionId": transaction_id
                },
                "data": {
                    "rut": rut_contribuyente,
                    "dv": dv,
                    "formId": form_id,
                    "mes": mes,
                    "anno": anio
                }
            }

            # Ejecutar petici√≥n
            import requests
            import json

            url = "https://www4.sii.cl/propuestaf29ui/services/data/facadeAdapterService/getDeclaracionConEstados"

            # Obtener cookies del driver
            selenium_cookies = self._driver.get_cookies()
            cookies_dict = {cookie['name']: cookie['value'] for cookie in selenium_cookies}

            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            }

            for attempt in range(max_retries):
                try:
                    logger.debug(f"Ejecutando petici√≥n (intento {attempt + 1}/{max_retries})")
                    logger.debug(f"Payload: {json.dumps(payload, indent=2)}")

                    response = requests.post(
                        url,
                        json=payload,
                        cookies=cookies_dict,
                        headers=headers,
                        timeout=30
                    )

                    if response.status_code == 200:
                        response_data = response.json()

                        # Verificar errores en metaData
                        metadata = response_data.get('metaData', {})
                        errors = metadata.get('errors')

                        if errors:
                            raise ExtractionError(f"Error en respuesta del SII: {errors}")

                        # Extraer data (puede ser lista vac√≠a)
                        declaraciones = response_data.get('data', [])

                        logger.info(
                            f"‚úÖ Declaraciones obtenidas: {len(declaraciones)} registros\n"
                            f"   Per√≠odo: {anio}-{mes}\n"
                            f"   Form ID: {form_id}"
                        )

                        return declaraciones
                    else:
                        logger.warning(f"‚ö†Ô∏è HTTP {response.status_code}: {response.text[:200]}")

                        if attempt < max_retries - 1:
                            import time
                            time.sleep(2)
                            continue
                        else:
                            raise ExtractionError(
                                f"Error HTTP {response.status_code}: {response.text[:200]}"
                            )

                except requests.exceptions.RequestException as e:
                    if attempt < max_retries - 1:
                        logger.warning(f"‚ö†Ô∏è Error en petici√≥n (intento {attempt + 1}): {str(e)}")
                        import time
                        time.sleep(2)
                        continue
                    else:
                        raise ExtractionError(f"Error en petici√≥n: {str(e)}") from e

            raise ExtractionError("No se pudo completar la petici√≥n despu√©s de varios intentos")

        except ValueError:
            raise
        except Exception as e:
            logger.error(
                f"‚ùå Error obteniendo declaraciones con estados\n"
                f"   Error: {type(e).__name__}: {str(e)}",
                exc_info=True
            )
            raise ExtractionError(f"Error obteniendo declaraciones: {str(e)}") from e

    def get_mensajes_contribuyente(
        self,
        periodo: str,
        form_id: str = "2",
        tipo: str = "IP",
        max_retries: int = 3
    ) -> Optional[Dict[str, Any]]:
        """
        Obtiene mensajes del SII para el contribuyente relacionados con una declaraci√≥n.

        Este m√©todo consulta mensajes, notificaciones o alertas que el SII
        tiene para el contribuyente sobre un per√≠odo tributario espec√≠fico.

        Args:
            periodo: Per√≠odo tributario en formato YYYYMM (ej: "202510")
            form_id: ID del formulario (default: "2" para F29)
            tipo: Tipo de mensaje (default: "IP" - probablemente "Informaci√≥n/Propuesta")
            max_retries: N√∫mero m√°ximo de reintentos en caso de error

        Returns:
            Dict con mensajes del contribuyente, o None si no hay mensajes:
            {
                'mensajes': [...],  # Lista de mensajes si existen
                'alertas': [...],   # Alertas o notificaciones
                # ... otros campos seg√∫n respuesta del SII
            }

            Si no hay mensajes, retorna None

        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            ExtractionError: Si falla la obtenci√≥n

        Example:
            >>> # Consultar mensajes para octubre 2025
            >>> mensajes = client.get_mensajes_contribuyente(periodo="202510")
            >>>
            >>> if mensajes:
            ...     print("Tienes mensajes del SII:")
            ...     print(mensajes)
            ... else:
            ...     print("No hay mensajes")

        Note:
            - Retorna None si no hay mensajes (data: null en respuesta)
            - El tipo "IP" parece ser para mensajes de Informaci√≥n/Propuesta
            - √ötil para detectar alertas antes de realizar una declaraci√≥n
        """
        from .scrapers.boletas_honorario_scraper import BoletasHonorarioScraper

        # Validar per√≠odo
        if not periodo or len(periodo) != 6 or not periodo.isdigit():
            raise ValueError("El per√≠odo debe estar en formato YYYYMM (ej: '202510')")

        self._ensure_initialized()

        # Asegurar autenticaci√≥n
        logger.info("üîê Mensajes contribuyente require authentication...")
        self.login()

        try:
            # Obtener datos del RUT
            scraper = BoletasHonorarioScraper(self._driver)
            rut_contribuyente, dv = scraper._obtener_datos_empresa()

            # Construir payload
            import uuid
            import random
            import string

            conversation_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))
            transaction_id = str(uuid.uuid4())

            payload = {
                "metaData": {
                    "namespace": "cl.sii.sdi.lob.iva.propuestaf29.data.api.interfaces.FacadeAdapterService/getMensajesContribuyente",
                    "conversationId": conversation_id,
                    "transactionId": transaction_id
                },
                "data": {
                    "rut": rut_contribuyente,
                    "periodo": periodo,
                    "formId": form_id,
                    "tipo": tipo
                }
            }

            # Ejecutar petici√≥n
            import requests
            import json

            url = "https://www4.sii.cl/propuestaf29ui/services/data/facadeAdapterService/getMensajesContribuyente"

            # Obtener cookies del driver
            selenium_cookies = self._driver.get_cookies()
            cookies_dict = {cookie['name']: cookie['value'] for cookie in selenium_cookies}

            headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            }

            for attempt in range(max_retries):
                try:
                    logger.debug(f"Ejecutando petici√≥n (intento {attempt + 1}/{max_retries})")
                    logger.debug(f"Payload: {json.dumps(payload, indent=2)}")

                    response = requests.post(
                        url,
                        json=payload,
                        cookies=cookies_dict,
                        headers=headers,
                        timeout=30
                    )

                    if response.status_code == 200:
                        response_data = response.json()

                        # Verificar errores en metaData
                        metadata = response_data.get('metaData', {})
                        errors = metadata.get('errors')

                        if errors:
                            raise ExtractionError(f"Error en respuesta del SII: {errors}")

                        # Extraer data (puede ser null)
                        mensajes = response_data.get('data')

                        if mensajes is None:
                            logger.info(
                                f"‚ÑπÔ∏è  No hay mensajes para el contribuyente\n"
                                f"   Per√≠odo: {periodo}\n"
                                f"   Form ID: {form_id}\n"
                                f"   Tipo: {tipo}"
                            )
                        else:
                            logger.info(
                                f"‚úÖ Mensajes obtenidos\n"
                                f"   Per√≠odo: {periodo}\n"
                                f"   Form ID: {form_id}\n"
                                f"   Tipo: {tipo}\n"
                                f"   Datos: {mensajes}"
                            )

                        return mensajes
                    else:
                        logger.warning(f"‚ö†Ô∏è HTTP {response.status_code}: {response.text[:200]}")

                        if attempt < max_retries - 1:
                            import time
                            time.sleep(2)
                            continue
                        else:
                            raise ExtractionError(
                                f"Error HTTP {response.status_code}: {response.text[:200]}"
                            )

                except requests.exceptions.RequestException as e:
                    if attempt < max_retries - 1:
                        logger.warning(f"‚ö†Ô∏è Error en petici√≥n (intento {attempt + 1}): {str(e)}")
                        import time
                        time.sleep(2)
                        continue
                    else:
                        raise ExtractionError(f"Error en petici√≥n: {str(e)}") from e

            raise ExtractionError("No se pudo completar la petici√≥n despu√©s de varios intentos")

        except ValueError:
            raise
        except Exception as e:
            logger.error(
                f"‚ùå Error obteniendo mensajes del contribuyente\n"
                f"   Error: {type(e).__name__}: {str(e)}",
                exc_info=True
            )
            raise ExtractionError(f"Error obteniendo mensajes: {str(e)}") from e
